# 1. 跨域+ Ajax

## 1.1. 什么是跨域？

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。

## 1.2. 什么是同源策略？

同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指**协议+域名+端口**三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。

同源策略限制以下几种行为：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 Js 对象无法获得
- AJAX 请求不能发送

## 1.3. 跨域的解决方案

1. 通过 jsonp 跨域
2. document.domain + iframe 跨域
3. location.hash + iframe
4. window.name + iframe 跨域
5. postMessage 跨域
6. 跨域资源共享（CORS）
7. nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

### 1.3.1. 通过 jsonp 跨域

通常为了减轻 web 服务器的负载，我们把 js、css，img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。

1. 原生实现：

   ```JavaScript
   var script = document.createElement('script');
   script.type = 'text/javascript';

   // 传参并指定回调执行函数为onBack
   script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
   document.head.appendChild(script);

   // 回调执行函数
   function onBack(res) {
   alert(JSON.stringify(res));
   }
   ```

   服务端返回如下（返回时即执行全局函数）：

   ```JavaScript
   onBack({"status": true, "user": "admin"})
   ```

2. jquery ajax：

   ```JavaScript
     $.ajax({
     url: 'http://www.domain2.com:8080/login',
     type: 'get',
     dataType: 'jsonp',  // 请求方式为jsonp
     jsonpCallback: "onBack",    // 自定义回调函数名
     data: {}
     });
   ```

3. vue.js：

   ```JavaScript
   this.$http.jsonp('http://www.domain2.com:8080/login', {
   params: {},
   jsonp: 'onBack'
   }).then((res) => {
   console.log(res);
   })
   ```

- Jsonp 优点:
  完美解决在测试或者开发中获取不同域下的数据，用户传递一个 callback 参数给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了
- Jsonp 缺点:
  Jsonp 只支持 get 请求而不支持 post 请求，也即是说如果想传给后台一个 json 格式的数据，浏览器会报一个 http 状态码 415 错误，告诉你请求格式不正确

### 1.3.2. postMessage 跨域

postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

`postMessage(data,origin)`方法接受两个参数

- data：html5 规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify()序列化。
- origin：协议+主机+端口号，也可以设置为"\*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

**使用场景**：窗口 A (http:A.com)向跨域的窗口 B (http:B.com)发送信息。步骤如下。

（1）在 A 窗口中操作如下：向 B 窗口发送数据：

```JavaScript
    // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
    Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象
```

（2）在 B 窗口中操作如下：

```JavaScript
    // 在窗口B中监听 message 事件
    Awindow.addEventListener('message', function (event) {   //这里强调的是A窗口里的window对象
        console.log(event.origin);  //获取 ：url。这里指：http://A.com
        console.log(event.source);  //获取：A window对象
        console.log(event.data);    //获取传过来的数据
    }, false);
```

### 1.3.3. 跨域资源共享（CORS）

普通跨域请求：只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的 cookie 为跨域请求接口所在域的 cookie，而非当前页。

目前，所有浏览器都支持该功能(IE8+：IE8/9 需要使用 XDomainRequest 对象来支持 CORS）)，CORS 也已经成为主流的跨域解决方案。

1. 原生 ajax

   ```JavaScript
   // 前端设置是否带cookie
   xhr.withCredentials = true;
   ```

   示例代码：

   ```JavaScript
   var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

   // 前端设置是否带cookie
   xhr.withCredentials = true;

   xhr.open('post', 'http://www.domain2.com:8080/login', true);
   xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
   xhr.send('user=admin');

   xhr.onreadystatechange = function() {
       if (xhr.readyState == 4 && xhr.status == 200) {
           alert(xhr.responseText);
       }
   };
   ```

2. jQuery ajax

   ```JavaScript
   $.ajax({
       ...
     xhrFields: {
         withCredentials: true    // 前端设置是否带cookie
     },
     crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
       ...
   });
   ```

3. vue 框架

   - axios 设置：

   ```JavaScript
   axios.defaults.withCredentials = true
   ```

   - vue-resource 设置：

   ```JavaScript
   Vue.http.options.credentials = true
   ```

### 1.3.4. WebSocket 协议跨域

WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

```html
<div>user input：<input type="text" /></div>
<script src="./socket.io.js"></script>
<script>
  var socket = io('http://www.domain2.com:8080')

  // 连接成功处理
  socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
      console.log('data from server: ---> ' + msg)
    })

    // 监听服务端关闭
    socket.on('disconnect', function() {
      console.log('Server socket has closed.')
    })
  })

  document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value)
  }
</script>
```

## 1.4. Ajax 的优缺点是什么？

- 优点：
  1. 最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
  2. 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
  3. 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax 的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
  4. 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。
- 缺点：
  1. ajax 不支持浏览器 back 按钮。
  2. 安全问题 AJAX 暴露了与服务器交互的细节。
  3. 对搜索引擎的支持比较弱。
  4. 破坏了程序的异常机制。
  5. 不容易调试

## 1.5. get 和 post 有什么区别？

![区别](https://user-gold-cdn.xitu.io/2018/11/16/1671bc56731bf8a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 1.6. 你是怎么理解 ajax 的？Ajax 的原理能说一下吗？

Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。

1. 创建 XMLHttpRequest 对象
2. 建立连接，设置为 GET 发送：xmlHttp.open("GET", "/ajax/getHint.jsp?q=" + txtValue, true);
3. 发送数据：xmlHttp.send();
4. 注册回调方法：xmlHttp.onreadystatechange = ajaxCallback;
5. 执行回调：

```JavaScript
function ajaxCallback(){
//响应就绪时
if(xmlHttp.readyState == 4 && xmlHttp.status == 200){
searchInput.value = xmlHttp.responseText;
 }
}
```

## 1.7. 你对同步和异步是怎么理解的？

- 同步：同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。
- 异步：不进入主线程、而进入"任务队列"（task queue）的任务，只有等主线程任务执行完毕，"任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行

## 1.8. 页面传参有没有出现过乱码的情况？如果有你是怎么解决的？

## 1.9. 在前后端数据交互的时候，有处理过（参数）数据加密的情况吗？

## 1.10. Json 字符串和 json 对象怎么相互转换？（重要）

- `JSON.parse()` 从一个字符串中解析出 json 对象
- `JSON.stringify()` 从一个对象中解析出字符串

## 1.11. Jq 封装的 Ajax 有多少个 callback？一般页面的 loading 层（加载的动画）都是写到那个回调函数里面？

## 1.12. 一个页面从输入 url 到页面加载显示完成，这个过程发生了什么？

1. 在浏览器地址栏输入 URL

2. 浏览器查看**缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤

   - 如果资源未缓存，发起新请求
   - 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
   - 检验新鲜通常有两个 HTTP 头进行控制`Expires`和 `Cache-Control`：
     - HTTP1.0 提供 `Expires`，值为一个绝对时间表示缓存新鲜日期
     - HTTP1.1 增加了 `Cache-Control: max-age=`,值为以秒为单位的最大新鲜时间

3. 浏览器**解析 URL**获取协议，主机，端口，path

4. 浏览器**组装一个 HTTP（GET）请求报文**

5. 浏览器**获取主机 ip 地址**，过程如下：

   1. 浏览器缓存
   2. 本机缓存
   3. hosts 文件
   4. 路由器缓存
   5. ISP DNS 缓存
   6. DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）

6. 打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：

   1. 客户端发送一个 TCP 的**SYN=1，Seq=X**的包到服务器端口，客户端进入 SYN_SEND 状态。
   2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包，服务器端进入 SYN_RCVD 状态。
   3. 客户端发送**ACK=Y+1， Seq=Z**

7. TCP 链接建立后**发送 HTTP 请求**

8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序

9. 服务器检查**HTTP 请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码

10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作

11. 服务器将**响应报文通过 TCP 连接发送回浏览器**

12. 浏览器接收 HTTP 响应，然后根据情况选择

    关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：

    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文

13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同

14. 如果资源可缓存，**进行缓存**

15. 对响应进行**解码**（例如 gzip 压缩）

16. 根据资源类型决定如何处理（假设资源为 HTML 文档）

17. **解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本**，这些操作没有严格的先后顺序，以下分别解释

18. 构建 DOM 树：

    1. **Tokenizing**：根据 HTML 规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据 HTML 标记关系将对象组成 DOM 树

19. 解析过程中遇到图片、样式表、js 文件，**启动下载**

20. 构建 CSSOM 树：

    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建 CSSOM 树

21. 根据 DOM 树和 CSSOM 树构建渲染树:

    1. 从 DOM 树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的 CSSOM 规则并应用
    3. 发布可视节点的内容和计算样式

22. js 解析如下：

    1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**
    2. HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素
    4. 当文档完成解析，document.readState 变成 interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()
    6. 浏览器**在 Document 对象上触发 DOMContentLoaded 事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件

23. **显示页面**（HTML 解析过程中会逐步显示页面）

## 1.13. http 的常用的状态码遇到过那些？分别代表什么意思？

- 1xx：指示信息——表示请求已接受，继续处理
- 2xx：成功——表示请求已被成功接收
- 3xx：重定向——要完成请求必须进行更进一步的操作
- 4xx：客户端错误——请求有语法错误或请求无法实现
- 5xx：服务器错误——服务器未能实现合法的请求

200 OK：客户端请求成功
206 Partial Content：客户发送了一个带有 Range 头的 GET 请求，服务器完成了它
301 Moved Permanently：永久重定向，所请求的页面已经转移到新的 url
302 Found：临时重定向，所请求的页面已经临时转移至新的 url
304 Not MOdified：缓存，客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用
400 Bad Request：客户端有语法错误，不能被服务器所理解
401 Unauthorized：请求未经授权，这个状态码必须和 WWW-Authenticate 报头域一起使用
403 Forbidden：对被请求页面的访问被禁止
404 Not Found：请求资源不存在
500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用
503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常

## 1.14. 使用 Async 会注意哪些东西

## 1.15. Async 里面有多个 await 请求，可以怎么优化（请求是否有依赖）

## 1.16. Promise 和 Async 处理失败的时候有什么区别
